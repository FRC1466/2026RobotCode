# 2026 Robot Code - Copilot Instructions

This is an FRC (FIRST Robotics Competition) robot project for team 1466 (Webb Robotics) using WPILib, AdvantageKit, and the Command-Based framework.

## Build, Test, and Deploy

### Building
```bash
./gradlew build
```

### Testing
```bash
# Run all tests
./gradlew test

# Run a specific test class
./gradlew test --tests "ClassName"
```

### Deployment
```bash
# Deploy to robot
./gradlew deploy

# The build.gradle includes a safety check that prevents deploying SIMBOT
# Set Constants.robot to COMPBOT or DEVBOT before deploying
```

### Simulation
```bash
# Run robot simulation with GUI
./gradlew simulateJava

# Run AdvantageKit log replay
./gradlew replayWatch
```

### Code Formatting
Spotless is configured to auto-format on compile. Manual formatting:
```bash
./gradlew spotlessApply
```

## High-Level Architecture

### Mode-Based Configuration (Constants.java)
- **RobotType enum**: COMPBOT, DEVBOT, SIMBOT - determines which hardware implementations to instantiate
- **Mode enum**: REAL, SIM, REPLAY - controls AdvantageKit logging behavior
- **Constants.robot** must be set to COMPBOT/DEVBOT for deployment (enforced by checkConstantsDeploy task)
- **Constants.tuningMode** must be false for pull requests (enforced by checkConstantsPullRequest task)

### AdvantageKit IO Pattern
All hardware subsystems follow the AdvantageKit IO layer pattern:
- **IO interface** (`*IO.java`) - defines inputs/outputs with `@AutoLog` annotation
- **IO implementations** (`*IOTalonFX.java`, `*IOSim.java`, etc.) - hardware-specific code
- **Subsystem class** - mode-agnostic logic, calls `io.updateInputs()` and `Logger.processInputs()`

Example: `ModuleIO`, `ModuleIOTalonFX`, `ModuleIOSim` → `Module`

The `@AutoLog` annotation generates `*IOInputsAutoLogged` classes at build time.

### Subsystem Organization

**Drive subsystem** (`subsystems/drive/`):
- Swerve drive using Phoenix 6 TalonFX motors
- `Drive` class uses `Module` objects for each swerve module
- `PhoenixOdometryThread` captures high-frequency odometry (100-250 Hz based on CAN FD)
- Integrated with PathPlanner for autonomous trajectories
- Uses `TunerConstants` (generated by Phoenix Tuner X)

**Vision subsystem** (`subsystems/vision/`):
- Supports PhotonVision and Limelight implementations
- Provides pose observations to Drive via consumer pattern: `Vision(drive::addVisionMeasurement, ...)`
- "Ramp mode" feature disables vision updates when crossing ramp, then aggressively corrects

**Shooter subsystems**:
- `Flywheel` and `Hood` - separate mechanism control
- `ShotCalculator` - calculates shooting parameters (heading, hood angle, flywheel speed) from robot pose
- Use `LoggedTunableNumber` for runtime tuning when `Constants.tuningMode` is enabled

**Choreographer** (superstructure):
- High-level state machine coordinating multiple subsystems
- Manages `Goal` (operator intent) → `State` (actual robot state) transitions
- Exposes `getTargetHeading()` for drive integration

### Specialized Utilities

**FullSubsystem** (`util/FullSubsystem.java`):
- Extends `SubsystemBase` with an additional `periodicAfterScheduler()` callback
- Called via `FullSubsystem.runAllPeriodicAfterScheduler()` in Robot.java
- Used for applying outputs after command scheduler runs (Hood, Flywheel extend this)

**LoggedTunableNumber** (`util/LoggedTunableNumber.java`):
- Runtime-tunable values via NetworkTables when `Constants.tuningMode` is true
- Falls back to defaults in competition mode
- Common pattern:
  ```java
  private static final LoggedTunableNumber kP = new LoggedTunableNumber("Path/kP", 0.5);
  ```

**RobotState** (singleton):
- Centralized storage for estimated pose and field velocity
- Updated by Drive subsystem, consumed by ShotCalculator and other subsystems

**AllianceFlipUtil**:
- Handles field coordinate flipping based on alliance color
- Critical for auto paths and vision targeting

## Key Conventions

### Copyright Header
All Java files must include:
```java
// Copyright (c) 2025-2026 Webb Robotics
// http://github.com/FRC1466
```
Enforced by Spotless license header check.

### Instantiation Pattern in RobotContainer
Subsystems are instantiated with different IO implementations based on `Constants.robot`:
```java
switch (Constants.robot) {
  case COMPBOT -> new Drive(new GyroIOPigeon2(), new ModuleIOTalonFX(...), ...);
  case DEVBOT -> new Drive(new GyroIOPigeon2(), new ModuleIOTalonFX(...), ...);
  case SIMBOT -> new Drive(new GyroIO() {}, new ModuleIOSim(...), ...);
}
```
Empty implementations (`new IO() {}`) are used when hardware is not present.

### Static Initialization for Mode-Specific Constants
Use static blocks to set different defaults per mode:
```java
static {
  switch (Constants.getMode()) {
    case REAL, REPLAY -> { kS.initDefault(0.19); }
    case SIM -> { kS.initDefault(0.0); }
  }
}
```

### Lombok Usage
- `@Getter` and `@Setter` for simple accessors
- `@ExtensionMethod` for utility method extension (see GeomUtil, TriggerUtil)

### Autonomous
- Choreography files (`.chor`) in Choreo/ directory generate trajectories
- PathPlanner library handles path following
- Auto commands selected via LoggedDashboardChooser

### Event Branch Auto-Commit
The `eventDeploy` task automatically commits working changes to Git when deploying from branches prefixed with "event".

## Vendor Libraries
Located in `vendordeps/`:
- Phoenix6 - CTRE motor controllers (Kraken/TalonFX)
- AdvantageKit - Logging and replay framework
- PathplannerLib - Trajectory generation and following
- ChoreoLib2026 - Choreo trajectory support
- PhotonLib - PhotonVision integration
- WPILibNewCommands - Command-based framework

## Code Style
- Google Java Format (enforced by Spotless)
- 2-space indentation for JSON and misc files
- 4-space indentation for Gradle files
- Minimal comments (code should be self-documenting; only clarify non-obvious intent)
